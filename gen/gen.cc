#include "co/def.h"
#include "co/str.h"
#include "co/fs.h"
#include "co/flag.h"
#include "co/log.h"
 
void generate(
    const fastring& gen_file, const fastring& pkg, const fastring& serv, 
    const std::vector<fastring>& methods
) {
    fs::fstream fs(gen_file.c_str(), 'w');
    if (!fs) {
        COUT << "cannot open file: " << gen_file;
        exit(0);
    }

    // service name: pkg.serv or serv
    fastring serv_name(pkg);
    if (!serv_name.empty()) serv_name.append('.');
    serv_name.append(serv);

    // name of client class
    fastring cli(serv + "Client");

    // packages.  "xx.yy" -> ["xx", "yy"]
    auto pkgs = str::split(pkg, '.');

    // includes
    do {
        fs << "// Autogenerated. DO NOT EDIT. All changes will be undone.\n\n";
        fs << "#pragma once\n\n";
        fs << "#include \"co/so/rpc.h\"\n\n";
    } while (0);

    // namespaces
    for (size_t i = 0; i < pkgs.size(); ++i) {
        fs << "namespace " << pkgs[i] << " {\n";
    }
    if (!pkgs.empty()) fs << "\n";

    // class for service
    fs << "class " << serv << " : public rpc::Service {\n";
    fs << "  public:\n";
    fs << fastring(' ', 4) << "typedef void (" << serv << "::*Fun)(const Json&, Json&);\n\n";

    do {
        fs << fastring(' ', 4) << serv << "() : _name(\"" << serv_name << "\") {\n";
        for (size_t i = 0; i < methods.size(); ++i) {
            fs << fastring(' ', 8) << "_methods[hash64(\"" << methods[i] << "\")] = &"
               << serv << "::" << methods[i] << ";\n";
        }
        fs << fastring(' ', 4) << "}\n\n";

        fs << fastring(' ', 4) << "virtual ~" << serv << "() {}\n\n";
    } while (0);

    // virtual void process(const Json& req, Json& res)
    do {
        fs << fastring(' ', 4) << "virtual const char* name() const {\n";
        fs << fastring(' ', 8) << "return _name.c_str();\n";
        fs << fastring(' ', 4) << "}\n\n";

        fs << fastring(' ', 4) << "virtual void process(const Json& req, Json& res) {\n";
        fs << fastring(' ', 8) << "json::Value method = req[\"method\"];\n";
        fs << fastring(' ', 8) << "if (!method.is_string()) {\n";
        fs << fastring(' ', 12) << "res.add_member(\"err\", 400);\n";
        fs << fastring(' ', 12) << "res.add_member(\"errmsg\", \"req has no method\");\n";
        fs << fastring(' ', 12) << "return;\n";
        fs << fastring(' ', 8) << "}\n\n";

        fs << fastring(' ', 8) << "auto it = _methods.find(hash64(method.get_string(), method.size()));\n";
        fs << fastring(' ', 8) << "if (it == _methods.end()) {\n";
        fs << fastring(' ', 12) << "res.add_member(\"err\", 404);\n";
        fs << fastring(' ', 12) << "res.add_member(\"errmsg\", \"method not found\");\n";
        fs << fastring(' ', 12) << "return;\n";
        fs << fastring(' ', 8) << "}\n\n";

        fs << fastring(' ', 8) << "(this->*it->second)(req, res);\n";
        fs << fastring(' ', 4) << "}\n\n";
    } while (0);

    // virtual void xxx(const Json& req, Json& res)
    for (size_t i = 0; i < methods.size(); ++i) {
        fs << fastring(' ', 4) << "virtual void " << methods[i] << "(const Json& req, Json& res) = 0;\n\n";
    }

    fs << "  private:\n";
    fs << "    std::unordered_map<uint64, Fun> _methods;\n";
    fs << "    fastring _name;\n";
    fs << "};\n";

    // generate class for client
    fs << '\n';
    fs << "class " << cli << " {\n";
    fs << "  public:\n";

    do {
        // constructor
        fs << fastring(' ', 4) << cli << "(const char* ip, int port, bool use_ssl=false)\n";
        fs << fastring(' ', 8) << ": _rpc_cli(ip, port, use_ssl), _serv_name(\"" << serv_name << "\") {\n";
        fs << fastring(' ', 4) << "}\n\n";

        // copy constructor
        fs << fastring(' ', 4) << cli << "(const " << cli << "& c)\n";
        fs << fastring(' ', 8) << ": _rpc_cli(c._rpc_cli), _serv_name(c._serv_name) {\n";
        fs << fastring(' ', 4) << "}\n\n";

        fs << fastring(' ', 4) << "~" << cli << "() {}\n\n";
    } while (0);

    // set_userpass
    fs << fastring(' ', 4) << "void " << "set_userpass(const char* user, const char* pass) {\n";
    fs << fastring(' ', 8) << "_rpc_cli.set_userpass(user, pass);\n";
    fs << fastring(' ', 4) << "}\n\n";

    // close
    fs << fastring(' ', 4) << "void " << "close() {\n";
    fs << fastring(' ', 8) << "_rpc_cli.close();\n";
    fs << fastring(' ', 4) << "}\n\n";

    // Json make_req_xxx()
    for (size_t i = 0; i < methods.size(); ++i) {
        fs << fastring(' ', 4) << "Json " << "make_req_" << methods[i] << "() {\n";
        fs << fastring(' ', 8) << "Json req;\n";
        fs << fastring(' ', 8) << "req.add_member(\"service\", _serv_name);\n";
        fs << fastring(' ', 8) << "req.add_member(\"method\", " << '"' << methods[i] << "\");\n";
        fs << fastring(' ', 8) << "return req;\n";
        fs << fastring(' ', 4) << "}\n\n";
    }

    // Json perform(const Json& req);
    fs << fastring(' ', 4) << "Json " << "perform" << "(const Json& req) {\n";
    fs << fastring(' ', 8) << "Json res;\n";
    fs << fastring(' ', 8) << "_rpc_cli.call(req, res);\n";
    fs << fastring(' ', 8) << "return res;\n";
    fs << fastring(' ', 4) << "}\n\n";

    // ping
    fs << fastring(' ', 4) << "void " << "ping" << "() {\n";
    fs << fastring(' ', 8) << "_rpc_cli.ping();\n";
    fs << fastring(' ', 4) << "}\n\n";

    fs << "  private:\n";
    fs << "    rpc::Client _rpc_cli;\n";
    fs << "    fastring _serv_name;\n";
    fs << "};\n";

    if (!pkgs.empty()) fs << '\n';

    for (size_t i = 0; i < pkgs.size(); ++i) {
        fs << "} // " << pkgs[i] << "\n";
    }

    fs.flush();
    COUT << "generate " << gen_file << " success";
}

void parse(const char* path) {
    fs::file f;
    if (!f.open(path, 'r')) {
        COUT << "failed to open file: " << path;
        exit(-1);
    }

    const char* b = strrchr(path, '/');
    if (b == 0) b = strrchr(path, '\\');
    b == 0 ? (b = path) : ++b;
    const char* e = strrchr(path, '.');

    if (e == 0 || e <= b) {
        COUT << "invalid proto file name: " << path;
        exit(-1);
    }

    fastring gen_file(fastring(b, e - b) + ".h");
    fastring pkg;
    fastring serv;
    std::vector<fastring> methods;

    auto s = f.read(fs::fsize(path));
    char c = '\n';
    if (!strchr(s.c_str(), '\n') && strchr(s.c_str(), '\r')) c = '\r';

    auto l = str::split(s.c_str(), c);

    for (size_t i = 0; i < l.size(); ++i) {
        auto x = str::strip(l[i]);
        if (x.empty()) continue;
        if (x.starts_with("//")) continue;

        if (x.starts_with("package ")) {
            if (!pkg.empty()) {
                COUT << "find multiple package name in file: " << path;
                exit(-1);
            }

            const char* p = strstr(x.c_str(), "//");
            if (p) x.resize(p - x.data());
            pkg = x.c_str() + 8;
            pkg = str::strip(pkg);
            continue;
        }

        if (x.starts_with("service ")) {
            if (!serv.empty()) {
                COUT << "find multiple service in file: " << path;
                exit(-1);
            }

            const char* p = strstr(x.c_str(), "//");
            if (p) x.resize(p - x.data());
            serv = x.c_str() + 8;
            serv = str::strip(serv, " \t\r\n{");

            for (size_t k = i + 1; k < l.size(); ++k) {
                const char* p = strstr(l[k].c_str(), "//");
                if (p) l[k].resize(p - l[k].data());

                if (l[k].find('}') != l[k].npos) {
                    auto m = str::strip(l[k], " \t\r\n,;{}");
                    if (!m.empty()) methods.push_back(m);
                    if (methods.empty()) {
                        COUT << "no method found in service: " << serv;
                        exit(-1);
                    }

                    generate(gen_file, pkg, serv, methods);
                    return;
                } else {
                    auto m = str::strip(l[k], " \t\r\n,;{");
                    if (!m.empty()) methods.push_back(m);
                }
            }

            COUT << "ending '}' not found for service: " << serv;
            exit(-1);
        }
    }
}

int main(int argc, char** argv) {
    auto v = flag::init(argc, argv);
    log::init();
    if (v.empty()) {
        COUT << "usage: gen xx.proto";
        return 0;
    }

    for (size_t i = 0; i < v.size(); ++i) {
        parse(v[i].c_str());
    }

    return 0;
}
